{"version":3,"file":"utils-Btq9dNEW.js","sources":["../../src/utils/randomCutGenerator.ts"],"sourcesContent":["import { BeatMarker, CutMarker } from '../types';\n\nconst COLORS = ['#F97316', '#3B82F6', '#10B981', '#8B5CF6', '#EF4444', '#F59E0B'];\n\ninterface RandomCutOptions {\n  startTime: number;\n  endTime: number;\n  planCount: number;\n  beatMarkers: BeatMarker[];\n  minCutInterval: number;\n  prioritizeStrongBeats: boolean;\n}\n\ninterface MeasureInfo {\n  startTime: number;\n  bpm: number;\n  confidence: number;\n}\n\ninterface DropMarker extends BeatMarker {\n  isDrop: boolean;\n  silenceDuration: number;\n}\n\n/**\n * D√©tecte les mesures musicales bas√©es sur les patterns de beats\n */\nfunction detectMeasures(beatMarkers: BeatMarker[]): MeasureInfo[] {\n  if (beatMarkers.length < 8) return [];\n\n  // Utiliser tous les beats pour une meilleure d√©tection du tempo\n  const allBeats = beatMarkers.filter(beat => beat.intensity > 0.1);\n  const strongBeats = beatMarkers.filter(beat => beat.type === 'strong');\n  \n  if (strongBeats.length < 3) return [];\n\n  // Analyser les intervalles entre tous les beats pour d√©tecter le tempo de base\n  const allIntervals: number[] = [];\n  for (let i = 1; i < allBeats.length; i++) {\n    const interval = allBeats[i].time - allBeats[i - 1].time;\n    if (interval > 0.15 && interval < 2) { // Intervalles r√©alistes pour des beats individuels\n      allIntervals.push(interval);\n    }\n  }\n\n  // Analyser les intervalles entre beats forts pour d√©tecter les mesures\n  const measureIntervals: number[] = [];\n  for (let i = 1; i < strongBeats.length; i++) {\n    const interval = strongBeats[i].time - strongBeats[i - 1].time;\n    if (interval > 0.8 && interval < 6) { // Intervalles r√©alistes pour des mesures (10-75 BPM en mesures)\n      measureIntervals.push(interval);\n    }\n  }\n\n  if (measureIntervals.length < 2) return [];\n\n  // Grouper les intervalles similaires pour trouver le pattern dominant\n  measureIntervals.sort((a: number, b: number) => a - b);\n  const clusters: number[][] = [];\n  let currentCluster: number[] = [measureIntervals[0]];\n\n  for (let i = 1; i < measureIntervals.length; i++) {\n    const diff = measureIntervals[i] - measureIntervals[i - 1];\n    if (diff < 0.3) { // Tol√©rance de 300ms pour les mesures\n      currentCluster.push(measureIntervals[i]);\n    } else {\n      if (currentCluster.length >= 1) {\n        clusters.push([...currentCluster]);\n      }\n      currentCluster = [measureIntervals[i]];\n    }\n  }\n  if (currentCluster.length >= 1) {\n    clusters.push(currentCluster);\n  }\n\n  // Prendre le cluster le plus fr√©quent\n  const dominantCluster = clusters.reduce((largest, current) => \n    current.length > largest.length ? current : largest, []);\n\n  if (dominantCluster.length < 2) return [];\n\n  // Calculer la dur√©e moyenne d'une mesure\n  const averageMeasureDuration = dominantCluster.reduce((sum, val) => sum + val, 0) / dominantCluster.length;\n  const bpm = 60 / (averageMeasureDuration / 4); // Supposer 4 temps par mesure\n\n  // Identifier les d√©buts de mesure probables\n  const measures: MeasureInfo[] = [];\n  let expectedNextMeasure = strongBeats[0].time;\n\n  for (const beat of strongBeats) {\n    const timeDiff = Math.abs(beat.time - expectedNextMeasure);\n    \n    if (timeDiff < averageMeasureDuration * 0.3) { // Tol√©rance de 30%\n      measures.push({\n        startTime: beat.time,\n        bpm,\n        confidence: Math.max(0.1, 1 - (timeDiff / averageMeasureDuration))\n      });\n      expectedNextMeasure = beat.time + averageMeasureDuration;\n    }\n  }\n\n  return measures.filter(m => m.confidence > 0.4); // Garder seulement les mesures confiantes\n}\n\n/**\n * D√©tecte les drops (beats forts apr√®s une p√©riode de silence relatif)\n */\nfunction detectDrops(beatMarkers: BeatMarker[]): DropMarker[] {\n  const drops: DropMarker[] = [];\n  const minSilenceDuration = 1.2; // Minimum 1.2s de \"silence\" avant un drop\n  const strongBeats = beatMarkers.filter(beat => beat.type === 'strong');\n\n  for (let i = 1; i < strongBeats.length; i++) {\n    const currentBeat = strongBeats[i];\n    const previousBeat = strongBeats[i - 1];\n    const silenceDuration = currentBeat.time - previousBeat.time;\n\n    // Un drop est un beat fort apr√®s une longue absence de beats forts\n    if (silenceDuration >= minSilenceDuration && currentBeat.intensity > 0.2) {\n      drops.push({\n        ...currentBeat,\n        isDrop: true,\n        silenceDuration\n      });\n    }\n  }\n\n  return drops;\n}\n\n/**\n * G√©n√®re des cuts al√©atoires intelligents bas√©s sur les beats d√©tect√©s\n */\nexport function generateRandomCuts({\n  startTime,\n  endTime,\n  planCount,\n  beatMarkers,\n  minCutInterval = 0.8,\n  prioritizeStrongBeats = true\n}: RandomCutOptions): CutMarker[] {\n  if (planCount < 2) return [];\n  \n  const cutsNeeded = planCount - 1; // nombre de cuts = nombre de plans - 1\n  const activeDuration = endTime - startTime;\n  \n  if (activeDuration < cutsNeeded * minCutInterval) {\n    console.warn('Not enough duration for the requested number of cuts');\n    return [];\n  }\n\n  // Filtrer les beats dans la zone active\n  const availableBeats = beatMarkers.filter(beat => \n    beat.time > startTime && beat.time < endTime\n  );\n\n  if (availableBeats.length === 0) {\n    return generateEquidistantCuts(startTime, endTime, cutsNeeded);\n  }\n\n  // D√©tecter les mesures et les drops\n  const measures = detectMeasures(availableBeats);\n  const drops = detectDrops(availableBeats);\n  \n  console.log(`üéµ D√©tect√© ${measures.length} mesures et ${drops.length} drops`);\n\n     // Cr√©er une liste prioris√©e de positions candidates\n   // Note: Les cuts sont plac√©s l√©g√®rement AVANT les beats pour un rendu plus fluide\n   const candidates: Array<BeatMarker & { priority: number; reason: string }> = [];\n\n     // 1. PRIORIT√â ABSOLUE : Drops (toujours inclus)\n   drops.forEach(drop => {\n     if (drop.time > startTime && drop.time < endTime) {\n       candidates.push({\n         ...drop,\n         time: Math.max(startTime + 0.05, drop.time - 0.05), // Cut 50ms avant le drop\n         priority: 100, // Priorit√© maximale\n         reason: 'drop'\n       });\n     }\n   });\n\n     // 2. PRIORIT√â HAUTE : D√©buts de mesure\n   measures.forEach(measure => {\n     const nearestBeat = availableBeats.find(beat => \n       Math.abs(beat.time - measure.startTime) < 0.2\n     );\n     if (nearestBeat && !candidates.some(c => Math.abs(c.time - nearestBeat.time) < 0.1)) {\n       candidates.push({\n         ...nearestBeat,\n         time: Math.max(startTime + 0.05, nearestBeat.time - 0.03), // Cut 30ms avant le beat\n         priority: 80 + (measure.confidence * 20), // 80-100 selon confiance\n         reason: 'measure_start'\n       });\n     }\n   });\n\n  // 3. PRIORIT√â MOYENNE : Milieux de mesure (beats forts)\n  if (measures.length > 0) {\n    const avgMeasureDuration = measures.length > 1 ? \n      (measures[measures.length - 1].startTime - measures[0].startTime) / (measures.length - 1) : \n      activeDuration / Math.max(1, measures.length);\n\n    measures.forEach(measure => {\n      const midMeasureTime = measure.startTime + (avgMeasureDuration / 2);\n      const nearestBeat = availableBeats.find(beat => \n        Math.abs(beat.time - midMeasureTime) < avgMeasureDuration * 0.3 &&\n        beat.type === 'strong'\n      );\n             if (nearestBeat && !candidates.some(c => Math.abs(c.time - nearestBeat.time) < 0.1)) {\n         candidates.push({\n           ...nearestBeat,\n           time: Math.max(startTime + 0.05, nearestBeat.time - 0.03), // Cut 30ms avant le beat\n           priority: 60 + (nearestBeat.intensity * 20), // 60-80\n           reason: 'measure_mid'\n         });\n       }\n    });\n  }\n\n     // 4. PRIORIT√â BASSE : Autres beats forts\n   availableBeats.filter(beat => beat.type === 'strong').forEach(beat => {\n     if (!candidates.some(c => Math.abs(c.time - beat.time) < 0.1)) {\n       candidates.push({\n         ...beat,\n         time: Math.max(startTime + 0.05, beat.time - 0.02), // Cut 20ms avant le beat\n         priority: 40 + (beat.intensity * 20), // 40-60\n         reason: 'strong_beat'\n       });\n     }\n   });\n\n  // Trier par priorit√© d√©croissante\n  candidates.sort((a, b) => b.priority - a.priority);\n\n     console.log(`üéØ ${candidates.length} candidats trouv√©s (ajust√©s avant beat):`, \n     candidates.slice(0, 8).map(c => `${c.reason} @${c.time.toFixed(2)}s (${c.priority.toFixed(0)})`));\n\n  // S√©lectionner les cuts en respectant les contraintes\n  const selectedCuts: CutMarker[] = [];\n  const forcedCuts = candidates.filter(c => c.reason === 'drop'); // Drops obligatoires\n\n  // D'abord, ajouter tous les drops\n  forcedCuts.forEach(drop => {\n    if (selectedCuts.length < cutsNeeded) {\n      selectedCuts.push({\n        id: crypto.randomUUID(),\n        time: drop.time,\n        color: COLORS[selectedCuts.length % COLORS.length],\n        duration: 1\n      });\n    }\n  });\n  \n  console.log(`üé§ ${forcedCuts.length} drops forc√©s ajout√©s, ${cutsNeeded - selectedCuts.length} cuts restants √† placer`);\n\n  // Ensuite, compl√©ter avec les autres candidats\n  for (const candidate of candidates) {\n    if (selectedCuts.length >= cutsNeeded) break;\n    if (candidate.reason === 'drop') continue; // D√©j√† ajout√©\n\n    // V√©rifier les conflits avec les cuts existants\n    const tooClose = selectedCuts.some(cut => \n      Math.abs(cut.time - candidate.time) < minCutInterval\n    );\n\n    if (!tooClose) {\n      selectedCuts.push({\n        id: crypto.randomUUID(),\n        time: candidate.time,\n        color: COLORS[selectedCuts.length % COLORS.length],\n        duration: 1\n      });\n    }\n  }\n\n  // Si on n'a pas assez de cuts, compl√©ter avec l'ancienne m√©thode\n  while (selectedCuts.length < cutsNeeded) {\n    const missingIndex = selectedCuts.length;\n    const idealTime = startTime + ((missingIndex + 1) * activeDuration / (cutsNeeded + 1));\n    \n    const nearestBeat = availableBeats\n      .filter(beat => !selectedCuts.some(cut => Math.abs(cut.time - beat.time) < minCutInterval))\n      .reduce((nearest, current) => {\n        const currentDistance = Math.abs(current.time - idealTime);\n        const nearestDistance = Math.abs(nearest.time - idealTime);\n        return currentDistance < nearestDistance ? current : nearest;\n      });\n\n         if (nearestBeat) {\n       selectedCuts.push({\n         id: crypto.randomUUID(),\n         time: Math.max(startTime + 0.05, nearestBeat.time - 0.02), // Cut 20ms avant le beat\n         color: COLORS[missingIndex % COLORS.length],\n         duration: 1\n       });\n     } else {\n       selectedCuts.push({\n         id: crypto.randomUUID(),\n         time: idealTime, // Position calcul√©e, pas de d√©calage\n         color: COLORS[missingIndex % COLORS.length],\n         duration: 1\n       });\n     }\n  }\n\n  // Optimiser les dur√©es et trier\n  const finalCuts = optimizeCutDurations(\n    selectedCuts.sort((a, b) => a.time - b.time), \n    endTime\n  );\n\n     console.log(`‚úÖ G√©n√©r√©s ${finalCuts.length} cuts (optimis√©s pour fluidit√©):`, \n     finalCuts.map((cut, i) => `Cut ${i+1}: ${cut.time.toFixed(2)}s`));\n\n  return finalCuts;\n}\n\n/**\n * Fallback: g√©n√®re des cuts √©quidistants quand pas de beats disponibles\n */\nfunction generateEquidistantCuts(startTime: number, endTime: number, count: number): CutMarker[] {\n  const duration = endTime - startTime;\n  const interval = duration / (count + 1);\n  \n  return Array.from({ length: count }, (_, i) => ({\n    id: crypto.randomUUID(),\n    time: startTime + (interval * (i + 1)),\n    color: COLORS[i % COLORS.length],\n    duration: Math.min(1, interval * 0.8)\n  }));\n}\n\n/**\n * Ajoute de la variabilit√© aux positions pour un effet plus naturel\n */\nexport function addTimeVariation(cuts: CutMarker[], maxVariation: number = 0.2): CutMarker[] {\n  return cuts.map(cut => ({\n    ...cut,\n    time: cut.time + (Math.random() - 0.5) * maxVariation\n  }));\n}\n\n/**\n * Optimise les dur√©es des cuts pour √©viter les chevauchements\n */\nexport function optimizeCutDurations(cuts: CutMarker[], endTime: number): CutMarker[] {\n  const sortedCuts = [...cuts].sort((a, b) => a.time - b.time);\n  \n  return sortedCuts.map((cut, index) => {\n    const nextCut = sortedCuts[index + 1];\n    const maxDuration = nextCut ? nextCut.time - cut.time : endTime - cut.time;\n    \n    return {\n      ...cut,\n      duration: Math.min(cut.duration, Math.max(0.3, maxDuration - 0.1))\n    };\n  });\n} "],"names":["COLORS","generateRandomCuts","startTime","endTime","planCount","beatMarkers","minCutInterval","prioritizeStrongBeats","cutsNeeded","activeDuration","availableBeats","filter","beat","time","length","count","duration","interval","Array","from","_","i","id","crypto","randomUUID","color","Math","min","generateEquidistantCuts","measures","allBeats","intensity","strongBeats","type","measureIntervals","push","sort","a","b","clusters","currentCluster","dominantCluster","reduce","largest","current","averageMeasureDuration","sum","val","bpm","expectedNextMeasure","timeDiff","abs","confidence","max","m","detectMeasures","drops","currentBeat","previousBeat","silenceDuration","isDrop","detectDrops","candidates","forEach","drop","priority","reason","measure","nearestBeat","find","some","c","avgMeasureDuration","midMeasureTime","selectedCuts","candidate","cut","missingIndex","idealTime","nearest","finalCuts","cuts","sortedCuts","map","index","nextCut","maxDuration","optimizeCutDurations"],"mappings":"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"}